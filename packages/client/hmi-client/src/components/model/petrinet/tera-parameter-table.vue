<template>
	<Accordion multiple :active-index="[0]">
		<AccordionTab>
			<template #header>
				<span class="mr-auto">
					Parameters<span class="artifact-amount">({{ numParameters }})</span>
				</span>
				<Button
					v-if="!isAddingUncertainty"
					label="Add uncertainty"
					outlined
					severity="secondary"
					size="small"
					@click.stop="onAddUncertainty"
					class="mr-2"
				/>
				<tera-input-text v-model="filterText" placeholder="Filter" class="w-2 p-1" />
			</template>

			<!-- Adding uncertainty header -->
			<span v-if="isAddingUncertainty" class="add-uncertainty-toolbar">
				<Button size="small" text label="Unselect all" @click="selectedParameters = []" />
				Add
				<Dropdown
					v-model="uncertaintyType"
					option-label="name"
					option-value="value"
					:options="distributionTypeOptions().filter((type) => type.value !== DistributionType.Constant)"
				>
					<template #value>
						{{ DistributionTypeLabel[uncertaintyType].toLowerCase() }}
					</template>
					<template #option="{ option }">
						{{ option.name.toLowerCase() }}
					</template>
				</Dropdown>
				uncertainty with Â±
				<InputNumber class="uncertainty-percentage" v-model="uncertaintyPercentage" suffix="%" :min="0" :max="100" />
				bounds on the value of the selected constant parameters.
				<Button text small icon="pi pi-check" @click="onUpdateDistributions" />
				<Button text small icon="pi pi-times" @click="isAddingUncertainty = false" class="ml-auto" />
			</span>

			<ul class="pl-1">
				<li v-for="{ baseParameter, childParameters, isVirtual } in parameterList" :key="baseParameter">
					<!-- Stratified -->
					<section v-if="isVirtual" class="parameter-entry-stratified">
						<Accordion multiple>
							<AccordionTab>
								<template #header>
									<span>{{ baseParameter }}</span>
									<Button label="Open Matrix" text size="small" @click.stop="matrixModalId = baseParameter" />
								</template>
								<div class="flex">
									<ul class="ml-1">
										<li v-for="{ referenceId } in childParameters" :key="referenceId">
											<div class="flex gap-4">
												<Checkbox
													v-if="
														isAddingUncertainty &&
														getParameterDistribution(modelConfiguration, referenceId).type === DistributionType.Constant
													"
													binary
													:model-value="selectedParameters.includes(referenceId)"
													@change="onSelect(referenceId)"
												/>
												<tera-parameter-entry
													:model="model"
													:model-configuration="props.modelConfiguration"
													:model-configurations="props.modelConfigurations"
													:parameter-id="referenceId"
													@update-parameter="emit('update-parameters', [$event])"
													@update-source="emit('update-source', $event)"
												/>
											</div>
											<Divider type="solid" />
										</li>
									</ul>
								</div>
							</AccordionTab>
						</Accordion>
					</section>
					<!-- Unstratified -->
					<div v-else class="flex gap-4">
						<Checkbox
							v-if="
								isAddingUncertainty &&
								getParameterDistribution(modelConfiguration, baseParameter).type === DistributionType.Constant
							"
							binary
							:model-value="selectedParameters.includes(baseParameter)"
							@change="onSelect(baseParameter)"
						/>
						<tera-parameter-entry
							:model="model"
							:model-configuration="modelConfiguration"
							:modelConfigurations="modelConfigurations"
							:parameter-id="baseParameter"
							@update-parameter="emit('update-parameters', [$event])"
							@update-source="emit('update-source', $event)"
						/>
					</div>
				</li>
			</ul>
		</AccordionTab>
	</Accordion>

	<tera-stratified-matrix-modal
		v-if="matrixModalId && isStratified"
		:id="matrixModalId"
		:mmt="mmt"
		:mmt-params="mmtParams"
		:stratified-matrix-type="StratifiedMatrix.Parameters"
		:open-value-config="!!matrixModalId"
		@close-modal="matrixModalId = ''"
		@update-cell-value="
			emit('update-parameters', [
				{
					id: $event.variableName,
					distribution: {
						type: DistributionType.Constant,
						parameters: { value: $event.newValue }
					}
				}
			])
		"
	/>
</template>

<script setup lang="ts">
import { Model, ModelConfiguration, ModelDistribution, ParameterSemantic } from '@/types/Types';
import { getParameterDistribution, getParameters } from '@/services/model-configurations';
import { StratifiedMatrix } from '@/types/Model';
import { computed, ref } from 'vue';
import { collapseParameters, isStratifiedModel } from '@/model-representation/mira/mira';
import { MiraModel, MiraTemplateParams } from '@/model-representation/mira/mira-common';
import Accordion from 'primevue/accordion';
import AccordionTab from 'primevue/accordiontab';
import Button from 'primevue/button';
import { DistributionType, DistributionTypeLabel, distributionTypeOptions } from '@/services/distribution';
import InputNumber from 'primevue/inputnumber';
import Dropdown from 'primevue/dropdown';
import Checkbox from 'primevue/checkbox';
import TeraInputText from '@/components/widgets/tera-input-text.vue';
import Divider from 'primevue/divider';
import TeraParameterEntry from './tera-parameter-entry.vue';
import TeraStratifiedMatrixModal from './model-configurations/tera-stratified-matrix-modal.vue';

const props = defineProps<{
	model: Model;
	modelConfiguration: ModelConfiguration;
	modelConfigurations: ModelConfiguration[];
	mmt: MiraModel;
	mmtParams: MiraTemplateParams;
}>();

const emit = defineEmits(['update-parameters', 'update-source']);

const isStratified = isStratifiedModel(props.mmt);

const isAddingUncertainty = ref(false);
const uncertaintyType = ref(DistributionType.Uniform);
const uncertaintyPercentage = ref(10);
const selectedParameters = ref<string[]>([]);
const filterText = ref('');

const numParameters = computed(() => parameterList.value.length);
const parameterList = computed<{ baseParameter: string; childParameters: ParameterSemantic[]; isVirtual: boolean }[]>(
	() => {
		const collapsedParameters = collapseParameters(props.mmt, props.mmtParams);
		const parameters = getParameters(props.modelConfiguration);
		return Array.from(collapsedParameters.keys())
			.map((id) => {
				const childIds = collapsedParameters.get(id) ?? [];
				const childParameters = childIds
					.map((childId) => parameters.find((p) => p.referenceId === childId))
					.filter(Boolean) as ParameterSemantic[];
				const isVirtual = childIds.length > 1;
				const baseParameter = id;

				return { baseParameter, childParameters, isVirtual };
			})
			.filter(({ baseParameter }) => baseParameter.toLowerCase().includes(filterText.value.toLowerCase()));
	}
);

const matrixModalId = ref('');

const onAddUncertainty = () => {
	const selected = Object.keys(props.mmt.parameters).filter(
		(paramId) => getParameterDistribution(props.modelConfiguration, paramId).type === DistributionType.Constant
	);
	selectedParameters.value = selected;
	isAddingUncertainty.value = true;
};

const onSelect = (paramId: string) => {
	if (selectedParameters.value.includes(paramId)) {
		selectedParameters.value.splice(selectedParameters.value.indexOf(paramId), 1);
	} else {
		selectedParameters.value.push(paramId);
	}
};

const onUpdateDistributions = () => {
	const distributionParameterMappings: { id: string; distribution: ModelDistribution }[] = [];
	if (uncertaintyType.value === DistributionType.Uniform) {
		selectedParameters.value.forEach((paramId) => {
			const distribution = getParameterDistribution(props.modelConfiguration, paramId);
			if (distribution.type !== DistributionType.Constant) return;

			const v = distribution.parameters.value;
			const delta = (distribution.parameters.value * uncertaintyPercentage.value) / 100;

			const distributionParameterMapping = {
				id: paramId,
				distribution: {
					type: uncertaintyType.value,
					// A way to get around the floating point precision issue is to set a fixed number of decimal places and parse as a float
					// This will be an issue for adding uncertainty to very small numbers, but I think 8 decimal points should do
					parameters: {
						minimum: parseFloat((v - delta).toFixed(8)),
						maximum: parseFloat((v + delta).toFixed(8))
					}
				}
			};
			distributionParameterMappings.push(distributionParameterMapping);
		});
	}

	emit('update-parameters', distributionParameterMappings);
	isAddingUncertainty.value = false;
};
</script>

<style scoped>
ul {
	flex-grow: 1;

	li {
		list-style: none;
	}

	li + li {
		border-top: 1px solid var(--gray-300);
		margin-top: var(--gap-1-5);
		padding-top: var(--gap-4);
	}

	li:last-child {
		margin-bottom: var(--gap-4);
	}
}

.parameter-entry-stratified {
	border-left: 4px solid var(--surface-300);
	padding-left: var(--gap-1);
}

:deep(.p-divider) {
	&.p-divider-horizontal {
		margin-top: var(--gap-2);
		margin-bottom: var(--gap-2);
		color: var(--gray-300);
	}
}

.stratified {
	ul {
		border-left: 1px solid var(--gray-300);
		margin-left: var(--gap-2);
		padding-left: var(--gap-4);
	}

	li {
		display: flex;
		gap: var(--gap-4);
	}
}

.artifact-amount {
	font-size: var(--font-caption);
	color: var(--text-color-subdued);
	margin-left: var(--gap-1);
}

.add-uncertainty-toolbar {
	display: flex;
	align-items: center;
	gap: var(--gap-2);
	background-color: var(--surface-highlight);
	padding: var(--gap-2);
	margin-bottom: var(--gap-2);
}

:deep(.uncertainty-percentage) > input {
	width: 4rem;
}
</style>
