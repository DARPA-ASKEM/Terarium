<template>
	<!-- add 'debug-mode' to debug this -->
	<tera-infinite-canvas
		@click="onCanvasClick()"
		@contextmenu="toggleContextMenu"
		@save-transform="saveTransform"
		@mouseleave="isMouseOverCanvas = false"
		@mouseenter="isMouseOverCanvas = true"
		@focus="() => {}"
		@blur="() => {}"
		@drop="onDrop"
		@dragover.prevent
		@dragenter.prevent
	>
		<!-- toolbar -->
		<template #foreground>
			<div class="toolbar glass">
				<div class="button-group">
					<InputText
						v-if="isRenamingWorkflow"
						class="p-inputtext-sm"
						v-model.lazy="newWorkflowName"
						placeholder="Workflow name"
						@keyup.enter="updateWorkflowName"
					/>
					<h5 v-else>{{ wf.name }}</h5>
					<Button
						icon="pi pi-ellipsis-v"
						class="p-button-icon-only p-button-text p-button-rounded"
						@click="toggleOptionsMenu"
					/>
				</div>
				<Menu ref="optionsMenu" :model="optionsMenuItems" :popup="true" />
				<div class="button-group">
					<Button label="Show all" class="secondary-button" text @click="resetZoom" />
					<Button label="Clean up layout" class="secondary-button" text @click="cleanUpLayout" />
					<Button icon="pi pi-plus" label="Add component" @click="showAddComponentMenu" />
					<Menu
						ref="addComponentMenu"
						:model="contextMenuItems"
						:popup="true"
						style="white-space: nowrap; width: auto"
					/>
				</div>
			</div>
		</template>
		<!-- data -->
		<template #data>
			<ContextMenu ref="contextMenu" :model="contextMenuItems" />
			<tera-workflow-node
				v-for="(node, index) in wf.nodes"
				:key="index"
				:node="node"
				@port-selected="(port: WorkflowPort, direction: WorkflowDirection) => createNewEdge(node, port, direction)"
				@port-mouseover="onPortMouseover"
				@port-mouseleave="onPortMouseleave"
				@dragging="(event) => updatePosition(node, event)"
				@remove-node="(event) => removeNode(event)"
				@drilldown="(event) => drilldown(event)"
				:canDrag="isMouseOverCanvas"
				:isActive="currentActiveNode?.id === node.id"
			>
				<template #body>
					<tera-model-node
						v-if="node.operationType === WorkflowOperationTypes.MODEL && models"
						:models="models"
						:dropped-model-id="droppedAssetId"
						:node="node"
						@select-model="(event) => selectModel(node, event)"
					/>
					<tera-dataset-node
						v-else-if="node.operationType === WorkflowOperationTypes.DATASET && datasets"
						:datasets="datasets"
						:dropped-dataset-id="droppedAssetId"
						:node="node"
						@select-dataset="(event) => selectDataset(node, event)"
					/>
					<tera-dataset-transformer-node
						v-else-if="
							node.operationType === WorkflowOperationTypes.DATASET_TRANSFORMER && datasets
						"
						:node="node"
						@append-input-port="(event) => appendInputPort(node, event)"
					/>
					<tera-model-transformer-node
						v-else-if="node.operationType === WorkflowOperationTypes.MODEL_TRANSFORMER && models"
						:node="node"
						@append-input-port="(event) => appendInputPort(node, event)"
					/>
					<tera-simulate-node-julia
						v-else-if="node.operationType === WorkflowOperationTypes.SIMULATE_JULIA"
						:node="node"
						@append-output-port="(event) => appendOutputPort(node, event)"
						@update-state="(event) => updateWorkflowNodeState(node, event)"
					/>
					<tera-simulate-node-ciemss
						v-else-if="node.operationType === WorkflowOperationTypes.SIMULATE_CIEMSS"
						:node="node"
						@append-output-port="(event) => appendOutputPort(node, event)"
						@update-state="(event) => updateWorkflowNodeState(node, event)"
					/>
					<tera-calibrate-node-julia
						v-else-if="node.operationType === WorkflowOperationTypes.CALIBRATION_JULIA"
						:node="node"
						@append-output-port="(event) => appendOutputPort(node, event)"
						@update-state="(event) => updateWorkflowNodeState(node, event)"
					/>
					<tera-calibrate-node-ciemss
						v-else-if="node.operationType === WorkflowOperationTypes.CALIBRATION_CIEMSS"
						:node="node"
						@append-output-port="(event) => appendOutputPort(node, event)"
						@update-state="(event) => updateWorkflowNodeState(node, event)"
					/>
					<tera-stratify-node-julia
						v-else-if="node.operationType === WorkflowOperationTypes.STRATIFY"
					/>
					<tera-simulate-ensemble-node-ciemss
						v-else-if="node.operationType === WorkflowOperationTypes.SIMULATE_ENSEMBLE_CIEMSS"
						:node="node"
						@append-output-port="(event) => appendOutputPort(node, event)"
						@update-state="(event) => updateWorkflowNodeState(node, event)"
					/>
					<tera-calibrate-ensemble-node-ciemss
						v-else-if="node.operationType === WorkflowOperationTypes.CALIBRATE_ENSEMBLE_CIEMSS"
						:node="node"
						@append-output-port="(event) => appendOutputPort(node, event)"
						@update-state="(event) => updateWorkflowNodeState(node, event)"
					/>
				</template>
			</tera-workflow-node>
		</template>
		<!-- background -->
		<template #backgroundDefs>
			<marker id="circle" markerWidth="8" markerHeight="8" refX="5" refY="5">
				<circle cx="5" cy="5" r="3" style="fill: var(--primary-color)" />
			</marker>
			<marker
				v-for="i in wf.edges.length"
				:key="i"
				:id="`circle${i - 1}`"
				markerWidth="8"
				markerHeight="8"
				refX="5"
				refY="5"
			>
				<circle cx="5" cy="5" r="3" :style="`fill: ${getVariableColorByRunIdx(i - 1)}`" />
			</marker>
			<marker
				id="arrow"
				viewBox="0 0 16 16"
				refX="8"
				refY="8"
				orient="auto"
				markerWidth="16"
				markerHeight="16"
				markerUnits="userSpaceOnUse"
				xoverflow="visible"
			>
				<path d="M 0 0 L 8 8 L 0 16 z" style="fill: var(--primary-color); fill-opacity: 1"></path>
			</marker>
			<marker
				id="smallArrow"
				viewBox="0 0 16 16"
				refX="8"
				refY="8"
				orient="auto"
				markerWidth="12"
				markerHeight="12"
				markerUnits="userSpaceOnUse"
				xoverflow="visible"
			>
				<path d="M 0 0 L 8 8 L 0 16 z" style="fill: var(--primary-color); fill-opacity: 1"></path>
			</marker>
			<marker
				v-for="i in wf.edges.length"
				:key="i"
				:id="`smallArrow${i - 1}`"
				viewBox="0 0 16 16"
				refX="8"
				refY="8"
				orient="auto"
				markerWidth="12"
				markerHeight="12"
				markerUnits="userSpaceOnUse"
				xoverflow="visible"
			>
				<path
					d="M 0 0 L 8 8 L 0 16 z"
					:style="`fill: ${getVariableColorByRunIdx(i - 1)}; fill-opacity: 1`"
				></path>
			</marker>
		</template>
		<template #background>
			<path
				v-if="newEdge?.points"
				:d="drawPath(interpolatePointsForCurve(newEdge.points[0], newEdge.points[1]))"
				stroke="#1B8073"
				stroke-width="2"
				marker-start="url(#circle)"
				marker-end="url(#arrow)"
				fill="none"
			/>
			<path
				v-for="(edge, index) of wf.edges"
				:d="drawPath(interpolatePointsForCurve(edge.points[0], edge.points[1]))"
				:stroke="isEdgeTargetSim(edge) ? getVariableColorByRunIdx(index) : '#1B8073'"
				stroke-width="2"
				:marker-start="`url(#circle${isEdgeTargetSim(edge) ? index : ''})`"
				:key="index"
				fill="none"
			/>
		</template>
	</tera-infinite-canvas>
</template>

<script setup lang="ts">
import { isArray, cloneDeep, isEqual } from 'lodash';
import { ref, onMounted, onUnmounted, computed, watch } from 'vue';
import { getModelConfigurations } from '@/services/model';
import TeraInfiniteCanvas from '@/components/widgets/tera-infinite-canvas.vue';
import {
	Operation,
	Position,
	Workflow,
	WorkflowEdge,
	WorkflowNode,
	WorkflowPort,
	WorkflowPortStatus,
	WorkflowDirection,
	WorkflowOperationTypes
} from '@/types/workflow';

// Operation imports
import TeraWorkflowNode from '@/workflow/tera-workflow-node.vue';
import ContextMenu from '@/components/widgets/tera-context-menu.vue';
import Button from 'primevue/button';
import InputText from 'primevue/inputtext';
import Menu from 'primevue/menu';
import * as workflowService from '@/services/workflow';
import * as d3 from 'd3';
import { AssetType, Dataset, Model } from '@/types/Types';
import { useDragEvent } from '@/services/drag-drop';
import { v4 as uuidv4 } from 'uuid';

import { useProjects } from '@/composables/project';
import { ModelOperation, TeraModelNode, ModelOperationState } from './ops/model/mod';
import { SimulateCiemssOperation, TeraSimulateNodeCiemss } from './ops/simulate-ciemss/mod';
import { StratifyOperation, TeraStratifyNodeJulia } from './ops/stratify-julia/mod';
import { DatasetOperation, TeraDatasetNode, DatasetOperationState } from './ops/dataset/mod';
import {
	CalibrateEnsembleCiemssOperation,
	TeraCalibrateEnsembleNodeCiemss
} from './ops/calibrate-ensemble-ciemss/mod';
import {
	DatasetTransformerOperation,
	TeraDatasetTransformerNode
} from './ops/dataset-transformer/mod';
import {
	CalibrationOperationJulia,
	TeraCalibrateNodeJulia,
	CalibrationOperationStateJulia
} from './ops/calibrate-julia/mod';
import { CalibrationOperationCiemss, TeraCalibrateNodeCiemss } from './ops/calibrate-ciemss/mod';
import {
	SimulateEnsembleCiemssOperation,
	TeraSimulateEnsembleNodeCiemss
} from './ops/simulate-ensemble-ciemss/mod';

import {
	SimulateJuliaOperation,
	SimulateJuliaOperationState,
	TeraSimulateNodeJulia
} from './ops/simulate-julia/mod';

import { ModelTransformerOperation, TeraModelTransformerNode } from './ops/model-transformer/mod';

const workflowEventBus = workflowService.workflowEventBus;
const WORKFLOW_SAVE_INTERVAL = 8000;

// Will probably be used later to save the workflow in the project
const props = defineProps<{
	assetId: string;
}>();

const newNodePosition = { x: 0, y: 0 };
let canvasTransform = { x: 0, y: 0, k: 1 };
let currentPortPosition: Position = { x: 0, y: 0 };
let isMouseOverPort: boolean = false;
let saveTimer: any = null;
let workflowDirty: boolean = false;

const currentActiveNode = ref<WorkflowNode<any> | null>();

workflowEventBus.on('clearActiveNode', () => {
	currentActiveNode.value = null;
});

const newEdge = ref<WorkflowEdge | undefined>();
const droppedAssetId = ref<string | null>(null);
const isMouseOverCanvas = ref<boolean>(false);

const wf = ref<Workflow>(workflowService.emptyWorkflow());
const contextMenu = ref();

// FIXME: temporary function to color edges with simulate
const VIRIDIS_14 = [
	'#440154',
	'#481c6e',
	'#453581',
	'#3d4d8a',
	'#34618d',
	'#2b748e',
	'#24878e',
	'#1f998a',
	'#25ac82',
	'#40bd72',
	'#67cc5c',
	'#98d83e',
	'#cde11d',
	'#fde725'
];

const isRenamingWorkflow = ref(false);
const newWorkflowName = ref('');

const optionsMenu = ref();
const optionsMenuItems = ref([
	{
		icon: 'pi pi-pencil',
		label: 'Rename',
		command() {
			isRenamingWorkflow.value = true;
			newWorkflowName.value = wf.value?.name ?? '';
		}
	}
]);

const toggleOptionsMenu = (event) => {
	optionsMenu.value.toggle(event);
};

const getVariableColorByRunIdx = (edgeIdx: number) =>
	wf.value.edges.length > 1
		? VIRIDIS_14[Math.floor((edgeIdx / wf.value.edges.length) * VIRIDIS_14.length)]
		: '#1B8073';
const isEdgeTargetSim = (edge) =>
	wf.value.nodes.find((node) => node.id === edge.target)?.operationType ===
	WorkflowOperationTypes.SIMULATE_JULIA;

const models = computed<Model[]>(() => useProjects().activeProject.value?.assets?.models ?? []);
const datasets = computed<Dataset[]>(
	() => useProjects().activeProject.value?.assets?.datasets ?? []
);

const refreshModelNode = async (node: WorkflowNode<ModelOperationState>) => {
	// FIXME: Need additional design to work out exactly what to show. June 2023
	const configurationList = await getModelConfigurations(node.state.modelId as string);
	configurationList.forEach((configuration) => {
		// Only add new configurations
		const existingConfig = node.outputs.find((port) => isEqual(port.value, [configuration.id]));
		if (existingConfig) {
			existingConfig.label = configuration.name;
			return;
		}

		node.outputs.push({
			id: uuidv4(),
			type: 'modelConfigId',
			label: configuration.name,
			value: [configuration.id],
			status: WorkflowPortStatus.NOT_CONNECTED
		});
	});
};

async function selectModel(node: WorkflowNode<ModelOperationState>, data: { id: string }) {
	droppedAssetId.value = null;
	node.state.modelId = data.id;
	await refreshModelNode(node);
}

async function updateWorkflowName() {
	const workflowClone = cloneDeep(wf.value);
	workflowClone.name = newWorkflowName.value;
	workflowService.updateWorkflow(workflowClone);
	isRenamingWorkflow.value = false;
	wf.value = await workflowService.getWorkflow(props.assetId);
	// FIXME: Names aren't updated in sidebar
}

async function selectDataset(
	node: WorkflowNode<DatasetOperationState>,
	data: { id: string; name: string }
) {
	droppedAssetId.value = null;
	node.state.datasetId = data.id;
	node.outputs = [
		{
			id: uuidv4(),
			type: 'datasetId',
			label: data.name,
			value: [data.id],
			status: WorkflowPortStatus.NOT_CONNECTED
		}
	];
	workflowDirty = true;
}
function appendInputPort(
	node: WorkflowNode<any>,
	port: { type: string; label?: string; value: any }
) {
	node.inputs.push({
		id: uuidv4(),
		type: port.type,
		label: port.label,
		status: WorkflowPortStatus.NOT_CONNECTED
	});
}

function appendOutputPort(
	node: WorkflowNode<any>,
	port: { type: string; label?: string; value: any }
) {
	node.outputs.push({
		id: uuidv4(),
		type: port.type,
		label: port.label,
		value: isArray(port.value) ? port.value : [port.value],
		status: WorkflowPortStatus.NOT_CONNECTED
	});

	// FIXME: This is a bit hacky, we should split this out into separate events, or the action
	// should be built into the Operation directly. What we are doing is to update the internal state
	// and this feels it is leaking too much low-level information
	if (
		node.operationType === WorkflowOperationTypes.CALIBRATION_JULIA ||
		node.operationType === WorkflowOperationTypes.CALIBRATION_CIEMSS
	) {
		const state = node.state as CalibrationOperationStateJulia;
		if (state.chartConfigs.length === 0) {
			// This only ends up showing the output of the first run, perhaps we should consider showing
			// the output of the last run, or all runs?
			state.chartConfigs.push({
				selectedRun: port.value[0],
				selectedVariable: []
			});
		}
	}

	if (
		node.operationType === WorkflowOperationTypes.SIMULATE_JULIA ||
		node.operationType === WorkflowOperationTypes.SIMULATE_CIEMSS
	) {
		const state = node.state as SimulateJuliaOperationState;
		if (state.simConfigs.chartConfigs.length === 0) {
			state.simConfigs.chartConfigs.push([]);
		}
		state.simConfigs.runConfigs[port.value[0]] = {
			runId: port.value[0],
			active: true
		};
	}

	workflowDirty = true;
}

function updateWorkflowNodeState(node: WorkflowNode<any>, state: any) {
	workflowService.updateNodeState(wf.value, node.id, state);
	workflowDirty = true;
}

const drilldown = (event: WorkflowNode<any>) => {
	currentActiveNode.value = event;
	workflowEventBus.emit('drilldown', event);
};

workflowEventBus.on('node-state-change', (payload: any) => {
	if (wf.value?.id !== payload.workflowId) return;
	workflowService.updateNodeState(wf.value, payload.nodeId, payload.state);
	workflowDirty = true;
});

workflowEventBus.on('node-refresh', (payload: { workflowId: string; nodeId: string }) => {
	if (wf.value?.id !== payload.workflowId) return;
	const node = wf.value.nodes.find((n) => n.id === payload.nodeId);
	if (!node) return;

	if (node.operationType === WorkflowOperationTypes.MODEL) {
		// This part is a bit hacky and slow. Because we allow multiple instances of the
		// same model across many nodes in a workflow, they ALL need to be updated. However
		// this multi-models setup is also somewhat uncommon so I don't want to go out of the way
		// to communicate "model change" instead of "node change", the former seemingly out of
		// place when using the WorkflowEventBus mechanism. DC - Aug 2023
		const nodesToRefresh = wf.value.nodes.filter((n) => n.state.modelId === node.state.modelId);
		nodesToRefresh.forEach(refreshModelNode);
	}
});

workflowEventBus.on(
	'add-node',
	(payload: { id: string; operation: Operation; position: Position; state: any }) => {
		workflowService.addNode(wf.value, payload.operation, payload.position, {
			state: payload.state
		});
		workflowDirty = true;
	}
);

workflowEventBus.on(
	'append-output-port',
	(payload: {
		node: WorkflowNode<any>;
		port: { id: string; type: string; label: string; value: string };
	}) => {
		const foundNode = wf.value.nodes.find((node) => node.id === payload.node.id);
		if (foundNode) {
			if (payload.port.type === 'datasetId') {
				foundNode.state.datasetId = payload.port.value;
			}
			appendOutputPort(foundNode, payload.port);
		}
	}
);

workflowEventBus.on('update-state', (payload: { node: WorkflowNode<any>; state }) => {
	const foundNode = wf.value.nodes.find((node) => node.id === payload.node.id);
	if (foundNode) {
		updateWorkflowNodeState(foundNode, payload.state);
	}
});

const removeNode = (event) => {
	workflowService.removeNode(wf.value, event);
};

const contextMenuItems = ref([
	{
		label: 'Model',
		command: () => {
			workflowService.addNode(wf.value, ModelOperation, newNodePosition);
			workflowDirty = true;
		}
	},
	{
		label: 'Dataset',
		command: () => {
			workflowService.addNode(wf.value, DatasetOperation, newNodePosition);
			workflowDirty = true;
		}
	},
	{
		label: 'Dataset Transformer',
		command: () => {
			workflowService.addNode(wf.value, DatasetTransformerOperation, newNodePosition);
			workflowDirty = true;
		}
	},
	{
		label: 'Model Transformer',
		command: () => {
			workflowService.addNode(wf.value, ModelTransformerOperation, newNodePosition);
			workflowDirty = true;
		}
	},
	{
		label: 'Stratify',
		command: () => {
			workflowService.addNode(wf.value, StratifyOperation, newNodePosition, { state: null });
			workflowDirty = true;
		}
	},
	{
		label: 'DETERMINISTIC',
		items: [
			{
				label: 'Simulate',
				command: () => {
					workflowService.addNode(wf.value, SimulateJuliaOperation, newNodePosition, {
						size: {
							width: 420,
							height: 220
						}
					});
					workflowDirty = true;
				}
			},
			{
				label: 'Simulate ensemble',
				disabled: true,
				command: () => {}
			},
			{
				label: 'Calibrate',
				command: () => {
					workflowService.addNode(wf.value, CalibrationOperationJulia, newNodePosition);
					workflowDirty = true;
				}
			}
		]
	},
	{
		label: 'PROBABILISTIC',
		items: [
			{
				label: 'Simulate',
				command: () => {
					workflowService.addNode(wf.value, SimulateCiemssOperation, newNodePosition, {
						size: {
							width: 420,
							height: 220
						}
					});
					workflowDirty = true;
				}
			},
			{
				label: 'Calibrate & Simulate',
				disabled: false,
				command: () => {
					workflowService.addNode(wf.value, CalibrationOperationCiemss, newNodePosition, {
						size: {
							width: 420,
							height: 220
						}
					});
					workflowDirty = true;
				}
			},
			{
				label: 'Simulate ensemble',
				disabled: false,
				command: () => {
					workflowService.addNode(wf.value, SimulateEnsembleCiemssOperation, newNodePosition, {
						size: {
							width: 420,
							height: 220
						}
					});
					workflowDirty = true;
				}
			},
			{
				label: 'Calibrate ensemble',
				disabled: false,
				command: () => {
					workflowService.addNode(wf.value, CalibrateEnsembleCiemssOperation, newNodePosition, {
						size: {
							width: 420,
							height: 220
						}
					});
					workflowDirty = true;
				}
			}
		]
	}
]);
const addComponentMenu = ref();
const showAddComponentMenu = (event) => addComponentMenu.value.toggle(event);

const { getDragData } = useDragEvent();

function onDrop(event) {
	const { assetId, assetType } = getDragData('initAssetNode') as {
		assetId: string;
		assetType: AssetType;
	};

	if (assetId && assetType) {
		updateNewNodePosition(event);

		let operation: Operation;

		switch (assetType) {
			case AssetType.Models:
				operation = ModelOperation;
				break;
			case AssetType.Datasets:
				operation = DatasetOperation;
				break;
			default:
				return;
		}

		workflowService.addNode(wf.value, operation, newNodePosition);
		droppedAssetId.value = assetId;
	}
}

function toggleContextMenu(event) {
	contextMenu.value.show(event);
	updateNewNodePosition(event);
}

function updateNewNodePosition(event) {
	newNodePosition.x = (event.offsetX - canvasTransform.x) / canvasTransform.k;
	newNodePosition.y = (event.offsetY - canvasTransform.y) / canvasTransform.k;
}

function saveTransform(newTransform: { k: number; x: number; y: number }) {
	canvasTransform = newTransform;

	const t = wf.value.transform;
	t.x = newTransform.x;
	t.y = newTransform.y;
	t.k = newTransform.k;
	workflowDirty = true;
}

const isCreatingNewEdge = computed(
	() => newEdge.value && newEdge.value.points && newEdge.value.points.length === 2
);

function createNewEdge(node: WorkflowNode<any>, port: WorkflowPort, direction: WorkflowDirection) {
	if (!isCreatingNewEdge.value) {
		newEdge.value = {
			id: 'new edge',
			workflowId: '0',
			points: [
				{ x: currentPortPosition.x, y: currentPortPosition.y },
				{ x: currentPortPosition.x, y: currentPortPosition.y }
			],
			source: direction === WorkflowDirection.FROM_OUTPUT ? node.id : undefined,
			sourcePortId: direction === WorkflowDirection.FROM_OUTPUT ? port.id : undefined,
			target: direction === WorkflowDirection.FROM_OUTPUT ? undefined : node.id,
			targetPortId: direction === WorkflowDirection.FROM_OUTPUT ? undefined : port.id,
			direction
		};
	} else {
		workflowService.addEdge(
			wf.value,
			newEdge.value!.source ?? node.id,
			newEdge.value!.sourcePortId ?? port.id,
			newEdge.value!.target ?? node.id,
			newEdge.value!.targetPortId ?? port.id,
			newEdge.value!.points
		);
		cancelNewEdge();
	}
}

function onCanvasClick() {
	if (isCreatingNewEdge.value) {
		cancelNewEdge();
	}
}

function cancelNewEdge() {
	newEdge.value = undefined;
}

function onPortMouseover(position: Position) {
	currentPortPosition = position;
	isMouseOverPort = true;
}

function onPortMouseleave() {
	isMouseOverPort = false;
}

let prevX = 0;
let prevY = 0;
function mouseUpdate(event: MouseEvent) {
	if (isCreatingNewEdge.value) {
		const pointIndex = newEdge.value?.direction === WorkflowDirection.FROM_OUTPUT ? 1 : 0;
		if (isMouseOverPort) {
			newEdge.value!.points[pointIndex].x = currentPortPosition.x;
			newEdge.value!.points[pointIndex].y = currentPortPosition.y;
		} else {
			const dx = event.x - prevX;
			const dy = event.y - prevY;
			newEdge.value!.points[pointIndex].x += dx / canvasTransform.k;
			newEdge.value!.points[pointIndex].y += dy / canvasTransform.k;
		}
	}
	prevX = event.x;
	prevY = event.y;
}

// TODO: rename/refactor
function updateEdgePositions(node: WorkflowNode<any>, { x, y }) {
	wf.value.edges.forEach((edge) => {
		if (edge.source === node.id) {
			edge.points[0].x += x / canvasTransform.k;
			edge.points[0].y += y / canvasTransform.k;
		}
		if (edge.target === node.id) {
			edge.points[edge.points.length - 1].x += x / canvasTransform.k;
			edge.points[edge.points.length - 1].y += y / canvasTransform.k;
		}
	});
}

const updatePosition = (node: WorkflowNode<any>, { x, y }) => {
	node.x += x / canvasTransform.k;
	node.y += y / canvasTransform.k;
	updateEdgePositions(node, { x, y });
	workflowDirty = true;
};

function interpolatePointsForCurve(a: Position, b: Position): Position[] {
	const controlXOffset = 50;
	return [a, { x: a.x + controlXOffset, y: a.y }, { x: b.x - controlXOffset, y: b.y }, b];
}

const pathFn = d3
	.line<{ x: number; y: number }>()
	.x((d) => d.x)
	.y((d) => d.y)
	.curve(d3.curveBasis);

// Get around typescript complaints
const drawPath = (v: any) => pathFn(v) as string;

watch(
	() => [props.assetId],
	async () => {
		isRenamingWorkflow.value = false; // Closes rename input if opened in previous workflow
		if (wf.value && workflowDirty) {
			workflowService.updateWorkflow(wf.value);
		}
		const workflowId = props.assetId;
		if (!workflowId) return;
		wf.value = await workflowService.getWorkflow(workflowId);
	},
	{ immediate: true }
);

onMounted(() => {
	document.addEventListener('mousemove', mouseUpdate);
	saveTimer = setInterval(() => {
		if (workflowDirty) {
			workflowService.updateWorkflow(wf.value);
			workflowDirty = false;
		}
	}, WORKFLOW_SAVE_INTERVAL);
});
onUnmounted(() => {
	if (workflowDirty) {
		workflowService.updateWorkflow(wf.value);
	}
	if (saveTimer) {
		clearInterval(saveTimer);
	}
	document.removeEventListener('mousemove', mouseUpdate);
});

function cleanUpLayout() {
	// TODO: clean up layout of nodes
	console.log('clean up layout');
}
function resetZoom() {
	// TODO: reset zoom level and position
	console.log('clean up layout');
}
</script>

<style scoped>
.toolbar {
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	padding: 0.5rem 1rem;
	border-top: 1px solid var(--surface-border-light);
	border-bottom: 1px solid var(--surface-border-light);
	z-index: 900;
}

.glass {
	background-color: rgba(255, 255, 255, 0.8);
	backdrop-filter: blur(10px);
}

.button-group {
	display: flex;
	align-items: center;
	flex-direction: row;
	gap: 1rem;
}

/* TODO: Create a proper secondary outline button in PrimeVue theme */
.toolbar .button-group .secondary-button {
	color: var(--text-color-secondary);
	background-color: var(--surface-0);
	border: 1px solid var(--surface-border-light);
}

.toolbar .button-group .secondary-button:enabled:hover {
	color: var(--text-color-secondary);
	background-color: var(--surface-highlight);
}

.toolbar .button-group .primary-dropdown {
	background-color: var(--primary-color);
	border: 1px solid var(--primary-color);
}

.toolbar .button-group .primary-dropdown:deep(.p-dropdown-label),
.toolbar .button-group .primary-dropdown:deep(.p-dropdown-trigger) {
	color: var(--surface-0);
	padding-top: 0.5rem;
	padding-bottom: 0.5rem;
}
</style>
